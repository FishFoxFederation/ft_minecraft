#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout (set = 0, binding = 0, rgba32f) uniform readonly image2D lighting_image;
layout (set = 0, binding = 1, rgba32f) uniform readonly image2D shadow_image;
layout (set = 1, binding = 0, rgba32f) uniform writeonly image2D output_image;

bool bound_check(ivec2 pos, ivec2 size)
{
	return pos.x >= 0 && pos.x < size.x && pos.y >= 0 && pos.y < size.y;
}

vec4 sampleShadow(ivec2 pos)
{
	float occlusion = imageLoad(shadow_image, pos).r;
	float depth = imageLoad(shadow_image, pos).g;
	float size = 10 / depth;
	int sample_count = 10;
	float sample_step = size / sample_count;
	float pixel_lit_count = 0;
	float pixel_lit_count_max = 0;

	if (occlusion == 0)
	{
		return vec4(0.0);
	}

	for (float i = -size / 2; i < size / 2; i += sample_step)
	{
		for (float j = -size / 2; j < size / 2; j += sample_step)
		{
			ivec2 sample_pos = pos + ivec2(i, j);
			if (!bound_check(sample_pos, imageSize(shadow_image)))
			{
				continue;
			}

			float sample_shadow = imageLoad(shadow_image, sample_pos).r;
			if (sample_shadow > 0.9)
			{
				pixel_lit_count += 1;
			}
			pixel_lit_count_max += 1;
		}
	}

	return vec4(pixel_lit_count / pixel_lit_count_max);
}

#define PI 3.14159265359

float distance(int x, int y, int i, int j)
{
    return float(sqrt(pow(x - i, 2) + pow(y - j, 2)));
}

float gaussian(float x, float sigma)
{
    return exp(-(pow(x, 2))/(2 * pow(sigma, 2))) / (2 * PI * pow(sigma, 2));
}

float bilateral_filtering(ivec2 pos)
{
	int diameter = 2;
	int radius = diameter / 2;
	float sigma_i = 12.0;
	float sigma_s = 16.0;
	float sum = 0.0;
	float weight = 0.0;
	float pixel = imageLoad(shadow_image, pos).r;

	for (int i = -radius; i <= radius; i++)
	{
		for (int j = -radius; j <= radius; j++)
		{
			ivec2 sample_pos = pos + ivec2(i, j);
			if (!bound_check(sample_pos, imageSize(shadow_image)))
			{
				continue;
			}

			float sample_pixel = imageLoad(shadow_image, sample_pos).r;
			float gi = gaussian(sample_pixel - pixel, sigma_i);
			float gs = gaussian(distance(pos.x, pos.y, sample_pos.x, sample_pos.y), sigma_s);
			float w = gi * gs;
			sum += sample_pixel * w;
			weight += w;
		}
	}

	return sum / weight;
}

void main()
{
	ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);
	ivec2 image_size = imageSize(lighting_image);

	if (!bound_check(storePos, image_size))
	{
		return;
	}

	vec4 lighting_pixel = imageLoad(lighting_image, storePos);
	vec4 shadow_pixel = imageLoad(shadow_image, storePos);

	// imageStore(output_image, storePos, lighting_pixel * (sampleShadow(storePos) * 0.5 + 0.5));
	// imageStore(output_image, storePos, lighting_pixel * shadow_pixel.r);
	imageStore(output_image, storePos, lighting_pixel * bilateral_filtering(storePos));
}
