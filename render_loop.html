<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VOX: Render Loop</title>
<!--BEGIN PROJECT_ICON-->
<link rel="icon" href="$projecticon" type="image/x-icon" />
<!--END PROJECT_ICON-->
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--BEGIN COPY_CLIPBOARD-->
<script type="text/javascript" src="clipboard.js"></script>
<!--END COPY_CLIPBOARD-->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
	DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">VOX
   </div>
   <div id="projectbrief">A little voxel engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('render_loop.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Render Loop </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_docs_pages_render_loop"></a> This page will explain how the render loop code works.</p>
<ul>
<li><a class="el" href="render_loop.html#main_rendering">Main rendering</a><ul>
<li><a class="el" href="render_loop.html#wait_for_previous_frame">Wait for previous frame</a></li>
<li><a class="el" href="render_loop.html#start_recording_command_buffer">Start recording command buffer</a></li>
<li><a class="el" href="render_loop.html#begin_main_rendering">Begin rendering</a></li>
<li><a class="el" href="render_loop.html#draw_the_chunks">Draw the chunks</a></li>
<li><a class="el" href="render_loop.html#draw_the_skybox">Draw the skybox</a></li>
<li><a class="el" href="render_loop.html#end_command_buffer">End command buffer</a></li>
</ul>
</li>
<li><a class="el" href="render_loop.html#swapchain">Swapchain</a><ul>
<li><a class="el" href="render_loop.html#acquire_image">Acquire image</a></li>
<li><a class="el" href="render_loop.html#transition_images_layout">Transition images layout</a></li>
<li><a class="el" href="render_loop.html#start_recording_copy_command_buffer">Start recording command buffer</a></li>
<li><a class="el" href="render_loop.html#copy_color_attachment_to_swapchain_image">Copy color attachment to swapchain image</a></li>
<li><a class="el" href="render_loop.html#end_copy_command_buffer">End command buffer</a></li>
<li><a class="el" href="render_loop.html#transition_images_layout_back">Transition images layout back</a></li>
</ul>
</li>
<li><a class="el" href="render_loop.html#imgui">ImGui</a><ul>
<li><a class="el" href="render_loop.html#start_recording_imgui_command_buffer">Start recording command buffer</a></li>
<li><a class="el" href="render_loop.html#begin_imgui_rendering">Begin rendering</a></li>
<li><a class="el" href="render_loop.html#render_imgui">Render ImGui</a></li>
<li><a class="el" href="render_loop.html#end_imgui_command_buffer">End command buffer</a></li>
</ul>
</li>
<li><a class="el" href="render_loop.html#present">Present</a><ul>
<li><a class="el" href="render_loop.html#transition_images_layout_present">Transition images layout</a></li>
<li><a class="el" href="render_loop.html#present_image">Present image</a></li>
</ul>
</li>
<li><a class="el" href="render_loop.html#conclusion">Conclusion</a><ul>
<li><a class="el" href="render_loop.html#possible_improvements">Possible improvements</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="main_rendering"></a>
Main rendering</h1>
<h3><a class="anchor" id="wait_for_previous_frame"></a>
Wait for previous frame</h3>
<p >First, we need to wait for the previous frame to finish rendering. This is done by calling <code>vkWaitForFences</code> with the fence of the current frame. This will block the CPU until the GPU has finished rendering the previous frame. After that, we reset the fence so that it can be used again.</p>
<div class="fragment"><div class="line">vkWaitForFences(vk.device, 1, &amp;vk.in_flight_fences[vk.current_frame], VK_TRUE, std::numeric_limits&lt;uint64_t&gt;::max());</div>
<div class="line">vkResetFences(vk.device, 1, &amp;vk.in_flight_fences[vk.current_frame]);</div>
</div><!-- fragment --><p >Since we can have multiple frames in flight, we access the current frame's fence by using <code>vk.current_frame</code>. This will be the case for all the other resources that are specific to a specific frame.</p>
<h3><a class="anchor" id="start_recording_command_buffer"></a>
Start recording command buffer</h3>
<p >We can start recording the command buffer for the current frame. We do this by calling <code>vkResetCommandBuffer</code> to reset the command buffer, and then <code>vkBeginCommandBuffer</code> to start recording.</p>
<div class="fragment"><div class="line">vkResetCommandBuffer(vk.render_command_buffers[vk.current_frame], 0);</div>
<div class="line"> </div>
<div class="line">VkCommandBufferBeginInfo begin_info = {};</div>
<div class="line">begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;</div>
<div class="line"> </div>
<div class="line">vkBeginCommandBuffer(vk.render_command_buffers[vk.current_frame], &amp;begin_info);</div>
</div><!-- fragment --><h3><a class="anchor" id="begin_main_rendering"></a>
Begin rendering</h3>
<p >We can now start rendering by calling <code>vkCmdBeginRendering</code>. This function takes a <code>VkRenderingInfo</code> struct that contains information about the rendering. Here we specify a color attachment and a depth attachment which are the images that we will render to.</p>
<div class="fragment"><div class="line">std::array&lt;VkRenderingAttachmentInfo, 1&gt; color_attachments = {};</div>
<div class="line">color_attachments[0].sType = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO;</div>
<div class="line">color_attachments[0].imageView = vk.color_attachement_view;</div>
<div class="line">color_attachments[0].imageLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;</div>
<div class="line">color_attachments[0].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;</div>
<div class="line">color_attachments[0].storeOp = VK_ATTACHMENT_STORE_OP_STORE;</div>
<div class="line">color_attachments[0].clearValue = { 0.0f, 0.0f, 0.0f, 1.0f };</div>
<div class="line"> </div>
<div class="line">VkRenderingAttachmentInfo depth_attachment = {};</div>
<div class="line">depth_attachment.sType = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO;</div>
<div class="line">depth_attachment.imageView = vk.depth_attachement_view;</div>
<div class="line">depth_attachment.imageLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;</div>
<div class="line">depth_attachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;</div>
<div class="line">depth_attachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;</div>
<div class="line">depth_attachment.clearValue = { 1.0f, 0 };</div>
<div class="line"> </div>
<div class="line">VkRenderingInfo render_info = {};</div>
<div class="line">render_info.sType = VK_STRUCTURE_TYPE_RENDERING_INFO;</div>
<div class="line">render_info.renderArea = { 0, 0, vk.color_attachement_extent.width, vk.color_attachement_extent.height };</div>
<div class="line">render_info.layerCount = 1;</div>
<div class="line">render_info.colorAttachmentCount = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(color_attachments.size());</div>
<div class="line">render_info.pColorAttachments = color_attachments.data();</div>
<div class="line">render_info.pDepthAttachment = &amp;depth_attachment;</div>
<div class="line"> </div>
<div class="line">vkCmdBeginRendering(vk.render_command_buffers[vk.current_frame], &amp;render_info);</div>
</div><!-- fragment --><h3><a class="anchor" id="draw_the_chunks"></a>
Draw the chunks</h3>
<p >First, we need to update the camera uniform buffer. This buffer contains the camera matrices that are used in the vertex shader for the chunks and the skybox as well.</p>
<div class="fragment"><div class="line">memcpy(vk.camera_uniform_buffers_mapped_memory[vk.current_frame], &amp;camera_matrices, <span class="keyword">sizeof</span>(camera_matrices));</div>
</div><!-- fragment --><p >Then we bind the pipeline and the descriptor sets.</p>
<div class="fragment"><div class="line">vkCmdBindPipeline(vk.render_command_buffers[vk.current_frame], VK_PIPELINE_BIND_POINT_GRAPHICS, vk.graphics_pipeline);</div>
<div class="line"> </div>
<div class="line">vkCmdBindDescriptorSets(</div>
<div class="line">    vk.render_command_buffers[vk.current_frame],</div>
<div class="line">    VK_PIPELINE_BIND_POINT_GRAPHICS,</div>
<div class="line">    vk.pipeline_layout,</div>
<div class="line">    0,</div>
<div class="line">    1,</div>
<div class="line">    &amp;vk.camera_descriptor_set,</div>
<div class="line">    0,</div>
<div class="line">    <span class="keyword">nullptr</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">vkCmdBindDescriptorSets(</div>
<div class="line">    vk.render_command_buffers[vk.current_frame],</div>
<div class="line">    VK_PIPELINE_BIND_POINT_GRAPHICS,</div>
<div class="line">    vk.pipeline_layout,</div>
<div class="line">    1,</div>
<div class="line">    1,</div>
<div class="line">    &amp;vk.texture_array_descriptor_set,</div>
<div class="line">    0,</div>
<div class="line">    <span class="keyword">nullptr</span></div>
<div class="line">);</div>
</div><!-- fragment --><p >Then we loop through all the chunk meshes and draw them if they are inside the view frustum. Each time updating the model matrix push constant which translates the chunk to its wolrd position.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; chunk_mesh : chunk_meshes)</div>
<div class="line">{</div>
<div class="line">    glm::dvec3 pos = chunk_mesh.transform.position();</div>
<div class="line">    <span class="keywordflow">if</span> (!camera.view_frustum.sphereInFrustum(pos + glm::dvec3(CHUNK_SIZE / 2), CHUNK_SIZE / 2 * std::sqrt(3)))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">continue</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    VkBuffer vertex_buffers[] = { vk.meshes[chunk_mesh.id].buffer };</div>
<div class="line">    VkDeviceSize offsets[] = { 0 };</div>
<div class="line">    vkCmdBindVertexBuffers(</div>
<div class="line">        vk.render_command_buffers[vk.current_frame],</div>
<div class="line">        0, 1,</div>
<div class="line">        vertex_buffers,</div>
<div class="line">        offsets</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    vkCmdBindIndexBuffer(</div>
<div class="line">        vk.render_command_buffers[vk.current_frame],</div>
<div class="line">        vk.meshes[chunk_mesh.id].buffer,</div>
<div class="line">        vk.meshes[chunk_mesh.id].index_offset,</div>
<div class="line">        VK_INDEX_TYPE_UINT32</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structModelMatrice.html">ModelMatrice</a> model_matrice = {};</div>
<div class="line">    model_matrice.<a class="code hl_variable" href="structModelMatrice.html#a13a189374fd6050fc659133ec5f8c537">model</a> = chunk_mesh.transform.model();</div>
<div class="line">    vkCmdPushConstants(</div>
<div class="line">        vk.render_command_buffers[vk.current_frame],</div>
<div class="line">        vk.pipeline_layout,</div>
<div class="line">        VK_SHADER_STAGE_VERTEX_BIT,</div>
<div class="line">        0,</div>
<div class="line">        <span class="keyword">sizeof</span>(<a class="code hl_struct" href="structModelMatrice.html">ModelMatrice</a>),</div>
<div class="line">        &amp;model_matrice</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    vkCmdDrawIndexed(</div>
<div class="line">        vk.render_command_buffers[vk.current_frame],</div>
<div class="line">        <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(vk.meshes[chunk_mesh.id].index_count),</div>
<div class="line">        1, 0, 0, 0</div>
<div class="line">    );</div>
<div class="line">}</div>
<div class="ttc" id="astructModelMatrice_html"><div class="ttname"><a href="structModelMatrice.html">ModelMatrice</a></div><div class="ttdef"><b>Definition:</b> ShaderCommon.hpp:29</div></div>
<div class="ttc" id="astructModelMatrice_html_a13a189374fd6050fc659133ec5f8c537"><div class="ttname"><a href="structModelMatrice.html#a13a189374fd6050fc659133ec5f8c537">ModelMatrice::model</a></div><div class="ttdeci">mat4 model</div><div class="ttdef"><b>Definition:</b> ShaderCommon.hpp:30</div></div>
</div><!-- fragment --><h3><a class="anchor" id="draw_the_skybox"></a>
Draw the skybox</h3>
<p >For the skybox we use a cube map texture that is rendered using a separate pipeline. The skybox is drawn last so that we can use the depth buffer that was created when drawing the chunks to only draw the skybox where necessary. As the skybox is always drawn around the camera, the model matrix is set to the camera position. Finally, the skybox is a simple cube so the vertices are hardcoded in the vertex shader.</p>
<div class="fragment"><div class="line">vkCmdBindPipeline(vk.render_command_buffers[vk.current_frame], VK_PIPELINE_BIND_POINT_GRAPHICS, vk.skybox_graphics_pipeline);</div>
<div class="line"> </div>
<div class="line">vkCmdBindDescriptorSets(</div>
<div class="line">    vk.render_command_buffers[vk.current_frame],</div>
<div class="line">    VK_PIPELINE_BIND_POINT_GRAPHICS,</div>
<div class="line">    vk.skybox_pipeline_layout,</div>
<div class="line">    0,</div>
<div class="line">    1,</div>
<div class="line">    &amp;vk.camera_descriptor_set,</div>
<div class="line">    0,</div>
<div class="line">    <span class="keyword">nullptr</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">vkCmdBindDescriptorSets(</div>
<div class="line">    vk.render_command_buffers[vk.current_frame],</div>
<div class="line">    VK_PIPELINE_BIND_POINT_GRAPHICS,</div>
<div class="line">    vk.skybox_pipeline_layout,</div>
<div class="line">    1,</div>
<div class="line">    1,</div>
<div class="line">    &amp;vk.cube_map_descriptor_set,</div>
<div class="line">    0,</div>
<div class="line">    <span class="keyword">nullptr</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structModelMatrice.html">ModelMatrice</a> camera_model_matrice = {};</div>
<div class="line">camera_model_matrice.<a class="code hl_variable" href="structModelMatrice.html#a13a189374fd6050fc659133ec5f8c537">model</a> = glm::translate(glm::dmat4(1.0f), camera.position);</div>
<div class="line">vkCmdPushConstants(</div>
<div class="line">    vk.render_command_buffers[vk.current_frame],</div>
<div class="line">    vk.skybox_pipeline_layout,</div>
<div class="line">    VK_SHADER_STAGE_VERTEX_BIT,</div>
<div class="line">    0,</div>
<div class="line">    <span class="keyword">sizeof</span>(<a class="code hl_struct" href="structModelMatrice.html">ModelMatrice</a>),</div>
<div class="line">    &amp;camera_model_matrice</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">vkCmdDraw(</div>
<div class="line">    vk.render_command_buffers[vk.current_frame],</div>
<div class="line">    36,</div>
<div class="line">    1,</div>
<div class="line">    0,</div>
<div class="line">    0</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="end_command_buffer"></a>
End command buffer</h3>
<p >Finally, we end the rendering and the command buffer and submit it to the graphics queue.</p>
<div class="fragment"><div class="line">vkCmdEndRendering(vk.render_command_buffers[vk.current_frame]);</div>
<div class="line"> </div>
<div class="line">vkEndCommandBuffer(vk.render_command_buffers[vk.current_frame]);</div>
<div class="line"> </div>
<div class="line">VkSubmitInfo render_submit_info = {};</div>
<div class="line">render_submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</div>
<div class="line">render_submit_info.commandBufferCount = 1;</div>
<div class="line">render_submit_info.pCommandBuffers = &amp;vk.render_command_buffers[vk.current_frame];</div>
<div class="line">render_submit_info.signalSemaphoreCount = 1;</div>
<div class="line">render_submit_info.pSignalSemaphores = &amp;vk.render_finished_semaphores[vk.current_frame];</div>
<div class="line"> </div>
<div class="line">vkQueueSubmit(vk.graphics_queue, 1, &amp;render_submit_info, vk.in_flight_fences[vk.current_frame]);</div>
</div><!-- fragment --><h1><a class="anchor" id="swapchain"></a>
Swapchain</h1>
<h3><a class="anchor" id="acquire_image"></a>
Acquire image</h3>
<p >After the rendering is submitted, we can acquire the next image from the swapchain. This is done by calling <code>vkAcquireNextImageKHR</code> which will return the index of the image that we can render to. Depending on the result, we might need to recreate the swapchain if it is out of date.</p>
<div class="fragment"><div class="line">uint32_t image_index;</div>
<div class="line">VkResult result = vkAcquireNextImageKHR(</div>
<div class="line">    vk.device,</div>
<div class="line">    vk.swap_chain,</div>
<div class="line">    std::numeric_limits&lt;uint64_t&gt;::max(),</div>
<div class="line">    vk.image_available_semaphores[vk.current_frame],</div>
<div class="line">    VK_NULL_HANDLE,</div>
<div class="line">    &amp;image_index</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR)</div>
<div class="line">{</div>
<div class="line">    vk.recreateSwapChain(vk.window);</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Failed to acquire swap chain image&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="transition_images_layout"></a>
Transition images layout</h3>
<p >We transition the swapchain image and the color attachment to the correct layout for the blit, e.i. <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> and <code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code> respectively.</p>
<div class="fragment"><div class="line">vk.transitionImageLayout(</div>
<div class="line">    vk.swap_chain_images[image_index],</div>
<div class="line">    VK_IMAGE_LAYOUT_UNDEFINED,</div>
<div class="line">    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</div>
<div class="line">    VK_IMAGE_ASPECT_COLOR_BIT,</div>
<div class="line">    1,</div>
<div class="line">    0,</div>
<div class="line">    0,</div>
<div class="line">    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,</div>
<div class="line">    VK_PIPELINE_STAGE_TRANSFER_BIT</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">vk.transitionImageLayout(</div>
<div class="line">    vk.color_attachement_image,</div>
<div class="line">    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,</div>
<div class="line">    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,</div>
<div class="line">    VK_IMAGE_ASPECT_COLOR_BIT,</div>
<div class="line">    1,</div>
<div class="line">    0,</div>
<div class="line">    0,</div>
<div class="line">    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,</div>
<div class="line">    VK_PIPELINE_STAGE_TRANSFER_BIT</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="start_recording_copy_command_buffer"></a>
Start recording command buffer</h3>
<p >We use a separate command buffer for the blit operation.</p>
<div class="fragment"><div class="line">vkResetCommandBuffer(vk.copy_command_buffers[vk.current_frame], 0);</div>
<div class="line"> </div>
<div class="line">VkCommandBufferBeginInfo copy_begin_info = {};</div>
<div class="line">copy_begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;</div>
<div class="line"> </div>
<div class="line">vkBeginCommandBuffer(vk.copy_command_buffers[vk.current_frame], &amp;copy_begin_info);</div>
</div><!-- fragment --><h3><a class="anchor" id="copy_color_attachment_to_swapchain_image"></a>
Copy color attachment to swapchain image</h3>
<p >We use blit because the color attachment may have a different size than the swapchain image which will allow us to do anti-aliasing for example.</p>
<div class="fragment"><div class="line">VkImageBlit blit = {};</div>
<div class="line">blit.srcOffsets[0] = { 0, 0, 0 };</div>
<div class="line">blit.srcOffsets[1] = {</div>
<div class="line">    <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(vk.color_attachement_extent.width),</div>
<div class="line">    <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(vk.color_attachement_extent.height),</div>
<div class="line">    1</div>
<div class="line">};</div>
<div class="line">blit.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</div>
<div class="line">blit.srcSubresource.mipLevel = 0;</div>
<div class="line">blit.srcSubresource.baseArrayLayer = 0;</div>
<div class="line">blit.srcSubresource.layerCount = 1;</div>
<div class="line">blit.dstOffsets[0] = { 0, 0, 0 };</div>
<div class="line">blit.dstOffsets[1] = {</div>
<div class="line">    <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(vk.swap_chain_extent.width),</div>
<div class="line">    <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(vk.swap_chain_extent.height),</div>
<div class="line">    1</div>
<div class="line">};</div>
<div class="line">blit.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</div>
<div class="line">blit.dstSubresource.mipLevel = 0;</div>
<div class="line">blit.dstSubresource.baseArrayLayer = 0;</div>
<div class="line">blit.dstSubresource.layerCount = 1;</div>
<div class="line"> </div>
<div class="line">vkCmdBlitImage(</div>
<div class="line">    vk.copy_command_buffers[vk.current_frame],</div>
<div class="line">    vk.color_attachement_image,</div>
<div class="line">    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,</div>
<div class="line">    vk.swap_chain_images[image_index],</div>
<div class="line">    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</div>
<div class="line">    1,</div>
<div class="line">    &amp;blit,</div>
<div class="line">    VK_FILTER_LINEAR</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="end_copy_command_buffer"></a>
End command buffer</h3>
<p >Finally, we end the command buffer and submit it to the graphics queue.</p>
<div class="fragment"><div class="line">vkEndCommandBuffer(vk.copy_command_buffers[vk.current_frame]);</div>
<div class="line"> </div>
<div class="line">VkSubmitInfo copy_submit_info = {};</div>
<div class="line">copy_submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</div>
<div class="line">copy_submit_info.commandBufferCount = 1;</div>
<div class="line">copy_submit_info.pCommandBuffers = &amp;vk.copy_command_buffers[vk.current_frame];</div>
<div class="line"> </div>
<div class="line">std::array&lt;VkSemaphore, 2&gt; copy_wait_semaphores = {</div>
<div class="line">    vk.image_available_semaphores[vk.current_frame],</div>
<div class="line">    vk.render_finished_semaphores[vk.current_frame]</div>
<div class="line">};</div>
<div class="line">std::array&lt;VkPipelineStageFlags, 2&gt; copy_wait_stages = {</div>
<div class="line">    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,</div>
<div class="line">    VK_PIPELINE_STAGE_TRANSFER_BIT</div>
<div class="line">};</div>
<div class="line">copy_submit_info.waitSemaphoreCount = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(copy_wait_semaphores.size());</div>
<div class="line">copy_submit_info.pWaitSemaphores = copy_wait_semaphores.data();</div>
<div class="line">copy_submit_info.pWaitDstStageMask = copy_wait_stages.data();</div>
<div class="line"> </div>
<div class="line">copy_submit_info.signalSemaphoreCount = 1;</div>
<div class="line">copy_submit_info.pSignalSemaphores = &amp;vk.swap_chain_updated_semaphores[vk.current_frame];</div>
<div class="line"> </div>
<div class="line">vkQueueSubmit(vk.graphics_queue, 1, &amp;copy_submit_info, VK_NULL_HANDLE);</div>
<div class="line"> </div>
<div class="line">vkQueueWaitIdle(vk.graphics_queue);</div>
</div><!-- fragment --><h3><a class="anchor" id="transition_images_layout_back"></a>
Transition images layout back</h3>
<p >After the blit operation, we need to transition the images layout back to <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> for the color attachment and <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> for the swapchain image because we will render to it the ImGui textures.</p>
<div class="fragment"><div class="line">vk.transitionImageLayout(</div>
<div class="line">    vk.color_attachement_image,</div>
<div class="line">    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,</div>
<div class="line">    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,</div>
<div class="line">    VK_IMAGE_ASPECT_COLOR_BIT,</div>
<div class="line">    1,</div>
<div class="line">    0,</div>
<div class="line">    0,</div>
<div class="line">    VK_PIPELINE_STAGE_TRANSFER_BIT,</div>
<div class="line">    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">vk.transitionImageLayout(</div>
<div class="line">    vk.swap_chain_images[image_index],</div>
<div class="line">    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</div>
<div class="line">    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,</div>
<div class="line">    VK_IMAGE_ASPECT_COLOR_BIT,</div>
<div class="line">    1,</div>
<div class="line">    0,</div>
<div class="line">    0,</div>
<div class="line">    VK_PIPELINE_STAGE_TRANSFER_BIT,</div>
<div class="line">    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</div>
<div class="line">);</div>
</div><!-- fragment --><h1><a class="anchor" id="imgui"></a>
ImGui</h1>
<h3><a class="anchor" id="start_recording_imgui_command_buffer"></a>
Start recording command buffer</h3>
<p >We create a new command buffer for the ImGui rendering.</p>
<div class="fragment"><div class="line">VkCommandBuffer imgui_command_buffer;</div>
<div class="line">VkCommandBufferAllocateInfo imgui_command_buffer_info = {};</div>
<div class="line">imgui_command_buffer_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;</div>
<div class="line">imgui_command_buffer_info.commandPool = vk.command_pool;</div>
<div class="line">imgui_command_buffer_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;</div>
<div class="line">imgui_command_buffer_info.commandBufferCount = 1;</div>
<div class="line"> </div>
<div class="line">vkAllocateCommandBuffers(vk.device, &amp;imgui_command_buffer_info, &amp;imgui_command_buffer);</div>
<div class="line"> </div>
<div class="line">VkCommandBufferBeginInfo imgui_begin_info = {};</div>
<div class="line">imgui_begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;</div>
<div class="line"> </div>
<div class="line">vkBeginCommandBuffer(imgui_command_buffer, &amp;imgui_begin_info);</div>
</div><!-- fragment --><h3><a class="anchor" id="begin_imgui_rendering"></a>
Begin rendering</h3>
<p >We start rendering with the swapchain image as the color attachment.</p>
<div class="fragment"><div class="line">VkRenderingAttachmentInfo imgui_color_attachment = {};</div>
<div class="line">imgui_color_attachment.sType = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO;</div>
<div class="line">imgui_color_attachment.imageView = vk.swap_chain_image_views[image_index];</div>
<div class="line">imgui_color_attachment.imageLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;</div>
<div class="line">imgui_color_attachment.loadOp = VK_ATTACHMENT_LOAD_OP_LOAD;</div>
<div class="line">imgui_color_attachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;</div>
<div class="line"> </div>
<div class="line">VkRenderingInfo imgui_render_info = {};</div>
<div class="line">imgui_render_info.sType = VK_STRUCTURE_TYPE_RENDERING_INFO;</div>
<div class="line">imgui_render_info.renderArea = { 0, 0, vk.swap_chain_extent.width, vk.swap_chain_extent.height };</div>
<div class="line">imgui_render_info.layerCount = 1;</div>
<div class="line">imgui_render_info.colorAttachmentCount = 1;</div>
<div class="line">imgui_render_info.pColorAttachments = &amp;imgui_color_attachment;</div>
<div class="line"> </div>
<div class="line">vkCmdBeginRendering(imgui_command_buffer, &amp;imgui_render_info);</div>
</div><!-- fragment --><h3><a class="anchor" id="render_imgui"></a>
Render ImGui</h3>
<p >We render the ImGui UI. The <code>m_debug_gui.updateImGui()</code> function will call the ImGui functions to render the UI.</p>
<div class="fragment"><div class="line">ImGui_ImplVulkan_NewFrame();</div>
<div class="line">ImGui_ImplGlfw_NewFrame();</div>
<div class="line">ImGui::NewFrame();</div>
<div class="line"> </div>
<div class="line">m_debug_gui.updateImGui();</div>
<div class="line"> </div>
<div class="line">ImGui::Render();</div>
<div class="line"> </div>
<div class="line">ImGui_ImplVulkan_RenderDrawData(ImGui::GetDrawData(), imgui_command_buffer);</div>
</div><!-- fragment --><h3><a class="anchor" id="end_imgui_command_buffer"></a>
End command buffer</h3>
<p >Finally, we end the command buffer and submit it to the graphics queue.</p>
<div class="fragment"><div class="line">vkCmdEndRendering(imgui_command_buffer);</div>
<div class="line"> </div>
<div class="line">vkEndCommandBuffer(imgui_command_buffer);</div>
<div class="line"> </div>
<div class="line">VkSubmitInfo imgui_submit_info = {};</div>
<div class="line">imgui_submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</div>
<div class="line">imgui_submit_info.commandBufferCount = 1;</div>
<div class="line">imgui_submit_info.pCommandBuffers = &amp;imgui_command_buffer;</div>
<div class="line">imgui_submit_info.waitSemaphoreCount = 1;</div>
<div class="line">imgui_submit_info.pWaitSemaphores = &amp;vk.swap_chain_updated_semaphores[vk.current_frame];</div>
<div class="line">VkPipelineStageFlags vk_pipeline_stage_flags = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;</div>
<div class="line">imgui_submit_info.pWaitDstStageMask = &amp;vk_pipeline_stage_flags;</div>
<div class="line">imgui_submit_info.signalSemaphoreCount = 1;</div>
<div class="line">imgui_submit_info.pSignalSemaphores = &amp;vk.imgui_render_finished_semaphores[vk.current_frame];</div>
<div class="line"> </div>
<div class="line">vkQueueSubmit(vk.graphics_queue, 1, &amp;imgui_submit_info, VK_NULL_HANDLE);</div>
<div class="line"> </div>
<div class="line">vkQueueWaitIdle(vk.graphics_queue);</div>
</div><!-- fragment --><h1><a class="anchor" id="present"></a>
Present</h1>
<h3><a class="anchor" id="transition_images_layout_present"></a>
Transition images layout</h3>
<p >We need to transition the swapchain image layout to <code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code> so that it can be presented.</p>
<div class="fragment"><div class="line">vk.transitionImageLayout(</div>
<div class="line">    vk.swap_chain_images[image_index],</div>
<div class="line">    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,</div>
<div class="line">    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,</div>
<div class="line">    VK_IMAGE_ASPECT_COLOR_BIT,</div>
<div class="line">    1,</div>
<div class="line">    0,</div>
<div class="line">    0,</div>
<div class="line">    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,</div>
<div class="line">    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="present_image"></a>
Present image</h3>
<p >Finally, we present the image to the swapchain. Optionally, we can recreate the swapchain if it is out of date.</p>
<div class="fragment"><div class="line">VkPresentInfoKHR present_info = {};</div>
<div class="line">present_info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;</div>
<div class="line">present_info.waitSemaphoreCount = 1;</div>
<div class="line">present_info.pWaitSemaphores = &amp;vk.imgui_render_finished_semaphores[vk.current_frame];</div>
<div class="line">present_info.swapchainCount = 1;</div>
<div class="line">present_info.pSwapchains = &amp;vk.swap_chain;</div>
<div class="line">present_info.pImageIndices = &amp;image_index;</div>
<div class="line"> </div>
<div class="line">result = vkQueuePresentKHR(vk.present_queue, &amp;present_info);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR)</div>
<div class="line">{</div>
<div class="line">    vk.recreateSwapChain(vk.window);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (result != VK_SUCCESS)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Failed to present swap chain image&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p >Finally, we increment the current frame index and we are ready to start rendering the next frame.</p>
<div class="fragment"><div class="line">vk.current_frame = (vk.current_frame + 1) % vk.max_frames_in_flight;</div>
</div><!-- fragment --><h1><a class="anchor" id="conclusion"></a>
Conclusion</h1>
<h3><a class="anchor" id="possible_improvements"></a>
Possible improvements</h3>
<ul>
<li>The render loop could be improved by using multiple threads to record the command buffers and submit them to the graphics queue.</li>
<li>If the render loop is done within one thread, we could use one single command buffer for the whole rendering process.</li>
<li>The occlusion culling could be done on the GPU. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
